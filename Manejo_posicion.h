
//-------------------------------------------------------------------------------------------------
// Funcion: void inicializacion_vector()
// inicializa los vectores
// Para una fecha
// Propuesta hacer una vector de logitud fija que la matematica lo llene
// Este vector es de simulacion cada un minuto

void inicializacion_vector(){
    hora_array_v[0]=8;
    min_array_v[0]=17;
    hora_array_v[1]=8;
    min_array_v[1]=18;
    hora_array_v[2]=8;
    min_array_v[2]=19;
    hora_array_v[3]=8;
    min_array_v[3]=20;
    hora_array_v[4]=8;
    min_array_v[4]=21;
    
    hora_array_v[5]=8;
    min_array_v[5]=22;
    hora_array_v[6]=8;
    min_array_v[6]=23;
    hora_array_v[7]=8;
    min_array_v[7]=24;
    
    hora_array_v[8]=8;
    min_array_v[8]=25;
    hora_array_v[9]=8;
    min_array_v[9]=26;
    hora_array_v[10]=8;
    min_array_v[10]=27;
    
    hora_array_v[11]=8;
    min_array_v[11]=28;
    hora_array_v[12]=8;
    min_array_v[12]=29;
    hora_array_v[13]=8;
    min_array_v[13]=30;
    
    hora_array_v[14]=8;
    min_array_v[14]=31;
    hora_array_v[15]=8;
    min_array_v[15]=32;
    hora_array_v[16]=8;
    min_array_v[16]=33;
    
    hora_array_v[17]=8;
    min_array_v[17]=34;
    hora_array_v[18]=8;
    min_array_v[18]=35;
    hora_array_v[19]=8;
    min_array_v[19]=36;
    
    hora_array_v[20]=8;
    min_array_v[20]=37;
    hora_array_v[21]=8;
    min_array_v[21]=38;
    hora_array_v[22]=8;
    min_array_v[22]=39;
    
    hora_array_v[23]=8;
    min_array_v[23]=40;
    hora_array_v[24]=8;
    min_array_v[24]=41;
    hora_array_v[25]=8;
    min_array_v[25]=42;
    
    hora_array_v[26]=8;
    min_array_v[26]=43;
    hora_array_v[27]=8;
    min_array_v[27]=44;
    hora_array_v[28]=8;
    min_array_v[28]=45;
    
    hora_array_v[29]=8;
    min_array_v[29]=46;
    hora_array_v[30]=8;
    min_array_v[30]=47;
    hora_array_v[31]=8;
    min_array_v[31]=48;
    
    hora_array_v[32]=8;
    min_array_v[32]=49;
    hora_array_v[33]=8;
    min_array_v[33]=50;
    hora_array_v[34]=8;
    min_array_v[34]=51;
    
    hora_array_v[35]=8;
    min_array_v[35]=52;
    hora_array_v[36]=8;
    min_array_v[36]=53;
    hora_array_v[37]=8;
    min_array_v[37]=54;
    
    hora_array_v[38]=8;
    min_array_v[38]=55;
    hora_array_v[39]=8;
    min_array_v[39]=56;
    hora_array_v[40]=8;
    min_array_v[40]=57;
    
    hora_array_v[41]=8;
    min_array_v[41]=58;
    hora_array_v[42]=8;
    min_array_v[42]=59;
    hora_array_v[43]=9;
    min_array_v[43]=00;
    
    //hora_array_v[44]=9;
    //min_array_v[44]=01;
    //hora_array_v[45]=9;
    //min_array_v[45]=02;
    //hora_array_v[46]=9;
    //min_array_v[46]=03;
}
//-------------------------------------------------------------------------------------------------
// Funcion: void inicializacion_vector_1()
// inicializa los vectores
// Para una fecha
// Propuesta hacer una vector de logitud fija que la matematica lo llene
// Este vector es de simulacion cada un minuto

void inicializacion_vector_1(){
    hora_array_v[0]=6;
    min_array_v[0]=48;
    hora_array_v[1]=7;
    min_array_v[1]=00;
    hora_array_v[2]=7;
    min_array_v[2]=20;
    hora_array_v[3]=7;
    min_array_v[3]=40;
    hora_array_v[4]=8;
    min_array_v[4]=00;
    
    hora_array_v[5]=8;
    min_array_v[5]=20;
    hora_array_v[6]=8;
    min_array_v[6]=40;
    hora_array_v[7]=9;
    min_array_v[7]=00;
    
    hora_array_v[8]=9;
    min_array_v[8]=20;
    hora_array_v[9]=9;
    min_array_v[9]=40;
    hora_array_v[10]=10;
    min_array_v[10]=00;
    
    hora_array_v[11]=10;
    min_array_v[11]=20;
    hora_array_v[12]=10;
    min_array_v[12]=40;
    hora_array_v[13]=11;
    min_array_v[13]=00;
    
    hora_array_v[14]=11;
    min_array_v[14]=20;
    hora_array_v[15]=11;
    min_array_v[15]=40;
    hora_array_v[16]=12;
    min_array_v[16]=00;
    
    hora_array_v[17]=12;
    min_array_v[17]=20;
    hora_array_v[18]=12;
    min_array_v[18]=40;
    hora_array_v[19]=13;
    min_array_v[19]=00;
    
    hora_array_v[20]=13;
    min_array_v[20]=20;
    hora_array_v[21]=13;
    min_array_v[21]=40;
    hora_array_v[22]=14;
    min_array_v[22]=00;
    
    hora_array_v[23]=14;
    min_array_v[23]=20;
    hora_array_v[24]=14;
    min_array_v[24]=40;
    hora_array_v[25]=15;
    min_array_v[25]=00;
    
    hora_array_v[26]=15;
    min_array_v[26]=20;
    hora_array_v[27]=15;
    min_array_v[27]=40;
    hora_array_v[28]=16;
    min_array_v[28]=00;
    
    hora_array_v[29]=16;
    min_array_v[29]=20;
    hora_array_v[30]=16;
    min_array_v[30]=40;
    hora_array_v[31]=17;
    min_array_v[31]=00;
    
    hora_array_v[32]=17;
    min_array_v[32]=20;
    hora_array_v[33]=17;
    min_array_v[33]=40;
    hora_array_v[34]=18;
    min_array_v[34]=00;
    
    hora_array_v[35]=18;
    min_array_v[35]=20;
    hora_array_v[36]=18;
    min_array_v[36]=40;
    hora_array_v[37]=19;
    min_array_v[37]=00;
    
    hora_array_v[38]=19;
    min_array_v[38]=20;
    hora_array_v[39]=19;
    min_array_v[39]=40;
    hora_array_v[40]=20;
    min_array_v[40]=00;
    
    hora_array_v[41]=20;
    min_array_v[41]=20;
    hora_array_v[42]=20;
    min_array_v[42]=40;
    hora_array_v[43]=21;
    min_array_v[43]=00;
    
    //hora_array_v[44]=20;
    //min_array_v[44]=00;
    //hora_array_v[45]=20;
    //min_array_v[45]=20;
    //hora_array_v[46]=20;
    //min_array_v[46]=40;
}


//-------------------------------------------------------------------------------------------------
// Funcion: void hora_a(String str)
// separa hora, minutos, segundos del operador ":"
// 
void hora_a(String str){
const char separador=':';
const int dataLenght=3;
//String str="";
int data[dataLenght];
//str=hora[indice_max];
 for (int i=0; i<dataLenght; i++)
 {
    int index=str.indexOf(separador);
    data[i]=str.substring(0,index).toInt();
    str=str.substring(index+1);
 }
  hora_array= data[0];
  min_array= data[1];
  seg_array= data[2];
  str="";
}

  
//-------------------------------------------------------------------------------------------------
// Funcion: void  print_AN()
// Imprime las AN's
// 
  
 void  print_AN(){
  Serial.print("AN0 vector:  ");
  //Serial.print(iAN0);
  Serial.print("  -AN0:");
  Serial.print(iAN0);
  Serial.print("  -AN2:");
  Serial.print(iAN2);
  Serial.print("  -AN1:");
  Serial.print(iAN1);
  Serial.print(" -AN3:");
  Serial.print(iAN3);
  Serial.print(" - D16B80: ");
  Serial.println(tempC);
 }


//-------------------------------------------------------------------------------------------------
// Funcion void envia_mensaje_sms(String tel, float tempC)
//
// Envia informacion via mensaje
// 


void envia_mensaje_sms(String tel, float tempC){
//--------------------------------------------------------
    // To send an SMS, call modem.sendSMS(SMS_TARGET, smsMessage)
   String smsMessage = "Ambar Reporta, estación : "+ String(Serie)+ " la temp es  " + String(tempC);
    // Aqui podemos agregar un boton de llamada de emergencia
    // Pulsamos un boton y podemos enviar un mensaje !!!!!    

    if(modem.sendSMS(tel, smsMessage)){
        SerialMon.println(smsMessage);
    }else{
      SerialMon.println("SMS failed to send");
    } 
}



//-------------------------------------------------------------------------------------------------
// Funcion void envia()
// Envia informacion a la nube
// estamos usando esta version

void envia() {
    SerialMon.print("Connecting to APN: ");
    SerialMon.print(apn);
    if (!modem.gprsConnect(apn, gprsUser, gprsPass)) {
      SerialMon.println(" fail al conectar APN");
    }else {
      SerialMon.println(" OK APN");
      SerialMon.print("Connecting to ");
      SerialMon.print(server);
    if (!client.connect(server, port)) {
      SerialMon.println(" fail en temporizador....");
    }else{
      SerialMon.println(" OK");
      // Making an HTTP POST request
      SerialMon.println("Performing HTTP POST request...");    
       String datos = "&elevacion=" + String(a_elevacion[ind]) + "&azimut=" + String(a_azimut[ind])+ "&an0=" + String(iAN0) + "&an1=" + String(iAN1) + "&an2=" + String(iAN2)+"&an3=" + String(iAN3) +"&Serie=" +String(Serie)+"&temp=" +String(tempC)+"&cam1=" +String(hora_rtc)+"&cam2=" +String(min_rtc)+"&cam3=" +String(encoder);

      //String datos = "&elevacion=" + String(2.29) + "&azimut=" + String(105.20)+ "&an0=" + String(100) + "&an1=" + String(200) + "&an2=" + String(300)+"&an3=" + String(400) +"&Serie=" +String(500);
      SerialMon.println(datos);
      SerialMon.print(F("Performing HTTPS GET request... "));
      http.connectionKeepAlive();  // Currently, this is needed for HTTPS
      int err = http.get(resource);
        if (err != 0) {
          SerialMon.println(F("failed to connect en http..."));
          SerialMon.print(err);
          delay(5000);
        }
      client.print(String("POST ") + resource + " HTTP/1.1\r\n");
      client.print(String("Host: ") + server + "\r\n");
      client.print(String("Accept: */*")+String("*\r\n"));
      client.print(String("Content-Length: ") + datos.length() + "\r\n");
      client.print(String("Content-Type: application/x-www-form-urlencoded") + String("\r\n"));
      client.print("\r\n" + datos);  
      
      unsigned long timeout = millis();
      while (client.connected() && millis() - timeout < 5000L) {
        // Print available data (HTTP response from server) // espera lo que envia el Servidor
        while (client.available()) {
          char c = client.read();
          SerialMon.print(c);
          timeout = millis();
        }
      }
    
    //--------------------------------------------------------
    // To send an SMS, call modem.sendSMS(SMS_TARGET, smsMessage)
    // String smsMessage = "Estación : "+ String(serie)+ " Temp:  " + String(tempF);
    // Aqui podemos agregar un boton de llamada de emergencia
    // Pulsamos un boton y podemos enviar un mensaje !!!!!    
/*
    if(modem.sendSMS(SMS_TARGET, smsMessage)){
        SerialMon.println(smsMessage);
    }
    else{
      SerialMon.println("SMS failed to send");
    }
*/
    //-------------------------------------------------------
      // Close client and disconnect
      client.stop();
      SerialMon.println(F("Server disconnected"));
      modem.gprsDisconnect();
      SerialMon.println(F("GPRS disconnected"));
    }
  }
}


//------------------------------------------------------------------------------
// Funcion: void configuracion_entrada_salida()
//
// config: entrada_salidas


 void configuracion_entrada_salida(){
  
  pinMode(Final_elv_0, INPUT);      // Entradas final de carrera
  pinMode(Final_elv_90, INPUT);     // Entradas final de carrera
  pinMode(Final_azim_0, INPUT);     // Entradas final de carrera
  pinMode(Final_azim_180, INPUT);
  
  pinMode(STEP_ME, OUTPUT);  // pin 4 como salida
  pinMode(DIR_ME, OUTPUT);   // pin 5 como salida
  pinMode(E_ME, OUTPUT);

  pinMode(STEP_MA, OUTPUT);  // pin 4 como salida
  pinMode(DIR_MA, OUTPUT);   // pin 5 como salida
  pinMode(E_MA, OUTPUT);
}

//------------------------------------------------------------------------------
// Función: void temporizador()
// Temporizador, esta funcion es la misma que envia() pero se lleva adelante cada cierto tiempor
// almacenada en la variable "ultimaConsulta"
// "tiempoConsulta"

void temporizador() {
  // Comprobar si se ha dado la vuelta
  if (millis() < ultimaConsulta) {
    // Asignar un nuevo valor
    ultimaConsulta = millis();
    SerialMon.print(ultimaConsulta);
  }
  if ((millis() - ultimaConsulta) > tiempoConsulta) {
    // Marca de tiempo
    ultimaConsulta = millis(); 
    SerialMon.print((millis() - ultimaConsulta));
    // Armar estructura y enviar datos a SQL
    //........................................................
    SerialMon.print("Connecting to APN: ");
    SerialMon.print(apn);
    if (!modem.gprsConnect(apn, gprsUser, gprsPass)) {
      SerialMon.println(" fail al conectar APN");
    }else {
      SerialMon.println(" OK APN");
      SerialMon.print("Connecting to ");
      SerialMon.print(server);
    if (!client.connect(server, port)) {
      SerialMon.println(" fail en temporizador....");
    }
    else {
      SerialMon.println(" OK");
      // Making an HTTP POST request
      SerialMon.println("Performing HTTP POST request...");
      // Prepare your HTTP POST request data (Temperature in Celsius degrees)
      // Para usar BME
      // displaybme();
      // String datos = "&satelites=" + String(satelites) + "&velocidad=" + String(velocidad)+ "&curso=" + String(curso) + "&altitud=" + String(altitud) + "&latitud=" + String(latitud,6) +"&Serie=" +String(serie) + "&longuitud=" + String(longuitud,6);
     
      
      //$sql ="INSERT INTO `stirling_1` (`ID`, `fecha`, `Serie`, `elevacion`, `azimut`, `an0`, `an1`, `an2`, `an3`, `temp`, `cam1`, `cam2`, `cam3`, `cam4`, `cam5`) VALUES (NULL, CURRENT_DATE(), '100', '23.56', '189.00', '123', '145', '156', '167', '200', '0', '0', '0', '0', '0')";
      //a_elevacion[ind],abs(dif_elevacion),flag_giro_elev,a_azimut[ind]
      
      String datos = "&elevacion=" + String(a_elevacion[ind]) + "&azimut=" + String(a_azimut[ind])+ "&an0=" + String(iAN0) + "&an1=" + String(iAN1) + "&an2=" + String(iAN2)+"&an3=" + String(iAN3) +"&Serie=" +String(Serie);
      //String datos = "&elevacion=" + String(2.29) + "&azimut=" + String(105.20)+ "&an0=" + String(100) + "&an1=" + String(200) + "&an2=" + String(300)+"&an3=" + String(400) +"&Serie=" +String(500);
      // Prepare your HTTP POST request data (Temperature in Fahrenheit degrees)
      // Para BME250 --- String httpRequestData = "api_key=" + apiKeyValue + "&value1=" + String(1.8 * bme.readTemperature() + 32)
      //                       + "&value2=" + String(bme.readHumidity()) + "&value3=" + String(bme.readPressure()/100.0F) + "";
      //temp_string=String(1.8 * bme.readTemperature()
               
      // You can comment the httpRequestData variable above
      // then, use the httpRequestData variable below (for testing purposes without the BME280 sensor)
      // String httpRequestData = "api_key=tPmAT5Ab3j7F9&value1=24.75&value2=49.54&value3=1005.14";
      SerialMon.println(datos);
      SerialMon.print(F("Performing HTTPS GET request... "));
      http.connectionKeepAlive();  // Currently, this is needed for HTTPS
      int err = http.get(resource);
        if (err != 0) {
          SerialMon.println(F("failed to connect en http..."));
          SerialMon.print(err);
          delay(5000);
        }
      client.print(String("POST ") + resource + " HTTP/1.1\r\n");
      client.print(String("Host: ") + server + "\r\n");
      client.print(String("Accept: */*")+String("*\r\n"));
      client.print(String("Content-Length: ") + datos.length() + "\r\n");
      client.print(String("Content-Type: application/x-www-form-urlencoded") + String("\r\n"));
      client.print("\r\n" + datos);  
      
      unsigned long timeout = millis();
      while (client.connected() && millis() - timeout < 5000L) {
        // Print available data (HTTP response from server) // espera lo que envia el Servidor
        while (client.available()) {
          char c = client.read();
          SerialMon.print(c);
          timeout = millis();
        }
      }
    
//--------------------------------------------------------
// To send an SMS, call modem.sendSMS(SMS_TARGET, smsMessage)
// String smsMessage = "Estación : "+ String(serie)+ " Temp:  " + String(tempF);
// Aqui podemos agregar un boton de llamada de emergencia
// Pulsamos un boton y podemos enviar un mensaje !!!!!    
/*
    if(modem.sendSMS(SMS_TARGET, smsMessage)){
        SerialMon.println(smsMessage);
    }
    else{
      SerialMon.println("SMS failed to send");
    }
*/
//-------------------------------------------------------
      // Close client and disconnect
      client.stop();
      SerialMon.println(F("Server disconnected"));
      modem.gprsDisconnect();
      SerialMon.println(F("GPRS disconnected"));
    }
  }
     
  }
}
////------------------------------------------------------------------------------------------------------
///                      fin funcion Temporizador
////------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------
// Elevacion
// Función: void elevacion (int grado_giro, bool flag_giro)
// recibe los grados de giro y lfag de giro
// giro LOW
// giro HIGH 
// 

void elevacion (int grado_giro, bool flag_giro){
//grado_giro=grado_giro*66; //(360/pasos_mot)*120;
//if (grado_giro>=0 & grado_giro<=90){
digitalWrite(E_ME, LOW);// Habilita el modulo que maneja Motor
// HIGH opuesto agujas del reloj
// LOW a favor
if (flag_giro_elev==0){digitalWrite(DIR_ME, LOW);}     // giro en sentido opuesto 
if (flag_giro_elev==1){digitalWrite(DIR_ME, HIGH);}     // giro en sentido 
if ( grado_giro==0&&digitalRead(Final_elv_0)==1){
    Serial.println("Elevacion Ya esta en  0!!!!");
    digitalWrite(E_ME, HIGH); // Desabilita el modulo que maneja Motor
    return;
}
//Serial.print("flag_giro_elev :");
//Serial.println(flag_giro_elev);
  for(int i = 0; i < grado_giro; i++){
    digitalWrite(STEP_ME, HIGH); 
    delay(periodo);
    digitalWrite(STEP_ME, LOW);
    delay(periodo);
      if ( (grado_giro>=90)&&(digitalRead(Final_elv_90))==1){
        Serial.println("Elevacion llegamos a 90!!!!");
        digitalWrite(E_ME, HIGH); // Desabilita el modulo que maneja Motor
        return;
      }
      
      if ( grado_giro==0&&digitalRead(Final_elv_0)==1){
        Serial.println("Elevacion llegamos a 0!!!!");
        digitalWrite(E_ME, HIGH); // Desabilita el modulo que maneja Motor
        return;
      }
  }
  digitalWrite(E_ME, HIGH); // Desabilita el modulo que maneja Motor
}

//---------------------------------------------------------------------------------------------------
// Azimut
// Función: void azimut(int grado_giro_a, bool f_giro)
// recibe los grados de giro y el fag de giro
// giro LOW giro en sentido opuesto a las agujas de reloj
// giro HIGH giro en sentido de las agujas del reloj
// 


void azimut(int grado_giro_a, bool f_giro){
//grado_giro=grado_giro*66;
digitalWrite(E_MA, LOW);     // giro en sentido opuesto
// HIGH opuesto agujas del reloj
// LOW a favor
if (f_giro==0){digitalWrite(DIR_MA, LOW);}      // giro en sentido opuesto a las agujas de reloj
if (f_giro==1){digitalWrite(DIR_MA, HIGH);}     // giro en sentido de las agujas del reloj
//Serial.print("flag_giro_azim :");
//Serial.println(flag_giro_azim);
   for(int i = 0; i < grado_giro_a; i++){
    digitalWrite(STEP_MA, HIGH); 
    delay(periodo);
    digitalWrite(STEP_MA, LOW);
    delay(periodo);
   //
   // Analizar si es necesario pararlo mientras esta haciendo la rutina???? de movimiento...
   // Sacando esta rutina no se para cuando encuentra el azimut 0....
   // Ademas se salva cuando queda activado el switch de azimut
   //-----------------------------------------------------------------------------------
    //if ( (digitalRead(Final_azim_0))==1){
    //  Serial.println("Azimut llegamos a 0 detro de azimut() !!!!");
      //digitalWrite(E_MA, HIGH); // Desabilita el modulo que maneja Motor 
      //return; 
    //}
   //-----------------------------------------------------------------------------------
  }
  digitalWrite(E_MA, HIGH); // Desabilita el modulo que maneja Motor
}

//---------------------------------------------------------------------------------------------------
// Buscar cero de elevacion
// Función: void buscar_cero_elevacion()
// recibe los grados de giro y el fag de giro
// giro LOW giro en sentido opuesto a las agujas de reloj
// giro HIGH giro en sentido de las agujas del reloj
// 

void buscar_cero_elevacion(){
 digitalWrite(E_ME, LOW);     
 digitalWrite(DIR_ME,LOW); // giro en sentido hacia la tierra
  for(int i = 0; i < pasos_elevacion; i++){
      digitalWrite(STEP_ME, HIGH); 
      delay(periodo);
      digitalWrite(STEP_ME, LOW);
      delay(periodo);
      if ( (digitalRead(Final_elv_0))==1){   
        Serial.println(" Elevacion Llegamos a 0 grado:  ");
        digitalWrite(E_ME,HIGH); // Saco enable para que no consuma
        return;
      }
  }
  digitalWrite(E_ME, HIGH);     // Saco enable
}

//---------------------------------------------------------------------------------------------------
// Buscar noventa grados de elevacion
// Función: void buscar_noventa_elevacion()
// recibe los grados de giro y el fag de giro
// giro LOW giro en sentido opuesto a las agujas de reloj
// giro HIGH giro en sentido de las agujas del reloj
// 

void buscar_noventa_elevacion(){
 digitalWrite(E_ME, LOW);     
 digitalWrite(DIR_ME,HIGH); // giro en sentido hacia el zenit
  
  for(int i = 0; i < pasos_elevacion; i++){
      digitalWrite(STEP_ME, HIGH); 
      delay(periodo);
      digitalWrite(STEP_ME, LOW);
      delay(periodo);
      if ( (digitalRead(Final_elv_90))==1){   
        Serial.println(" Elevación Llegamos a 90 grado:  ");
        digitalWrite(E_ME,HIGH); // Saco enable para que no consuma
        return;
      }
  }
   digitalWrite(E_ME, HIGH);     // Saco enable
}

//----------------------------------------------------------------------------------------------
//
// Buscar cero de azimut
// Función: void buscar_cero_azimut(float a_azi)
// recibe el angulo 
// Habilita el modulo, reserva energetica!!!
// buscar_cero_azimut(float a_azi)
// a_azi esta entre 240 y 360  gira a la derecha
// a_azi esta 0 entre 180  gira a la izquierda
//
// digitalWrite(DIR_MA,HIGH); // gira a la derecha
// digitalWrite(STEP_MA, LOW); // gira a la izquierda

void buscar_cero_azimut(float a_azi){
 digitalWrite(E_MA, LOW);     // Habilita el modulo
  Serial.print(" Angulo recibido... ");
  Serial.println(a_azi);
 //digitalWrite(DIR_MA,LOW);    // giro en sentido opuesto a las agujas de reloj
 if ((a_azi>=240) && (a_azi<=360)){ 
  Serial.print(" Entre 240 y 360 - HIGH - 1 ");
  Serial.println(a_azi);
  digitalWrite(DIR_MA,HIGH); // gira a la derecha, a favor Agujas de reloj
  }
 if ((a_azi>=0) && (a_azi<=180)){
  Serial.print(" Entre 0 y 180 - LOW - 0");
  Serial.println(a_azi);
  digitalWrite(DIR_MA,LOW); // giro en sentido contrario de las agujas del reloj
  }
  for(int i = 0; i < pasos_azimut; i++){
      digitalWrite(STEP_MA, HIGH); 
      delay(periodo);
      digitalWrite(STEP_MA, LOW);
      delay(periodo);
      if ( (digitalRead(Final_azim_0))==1){   
        Serial.println("Azimut Llegamos a 0 grado:  ");
        digitalWrite(E_MA, HIGH); // Desabilita el modulo que maneja Motor
        return;
      }
  }
  digitalWrite(E_MA, HIGH); // Desabilita el modulo que maneja Motor
}

//----------------------------------------------------------------------------------------------
//
// Buscar los 180 grados de azimut
// Función: void buscar_180_azimut(float a_azi)
// recibe el angulo 
// Habilita el modulo, reserva energetica!!!
//
// a_azi esta entre 240 y 360  gira a la derecha
// a_azi esta 0 entre 180  gira a la izquierda
//
// digitalWrite(DIR_MA,HIGH); // gira a la derecha
// digitalWrite(STEP_MA, LOW); // gira a la izquierda


void buscar_180_azimut(float a_azi){
 digitalWrite(E_MA, LOW);     // Habilita el modulo
 //digitalWrite(DIR_MA,LOW);    // giro en sentido opuesto a las agujas de reloj
 if ((a_azi>=240) && (a_azi<=360)){ 
  Serial.print(" Entre 240 y 360 - HIGH - 1 ");
  Serial.println(a_azi);
  digitalWrite(DIR_MA,LOW);
  }
 if ((a_azi>=0) && (a_azi<=180)){
  Serial.print(" Entre 0 y 180 - LOW - 0");
  Serial.println(a_azi);
  digitalWrite(DIR_MA,LOW);
  }
  for(int i = 0; i < pasos_azimut; i++){
      digitalWrite(STEP_MA, HIGH); 
      delay(periodo);
      digitalWrite(STEP_MA, LOW);
      delay(periodo);
      if ( (digitalRead(Final_azim_180))==1){   
        Serial.println("Azimut Llegamos a 180 grado:  ");
        //digitalWrite(DIR_ME,HIGH);
        return;
      }
  }
  digitalWrite(E_MA, HIGH); // Desabilita el modulo que maneja Motor
}
void vuelta_entera_azimut(){
 digitalWrite(E_MA, LOW);     // giro en sentido opuesto
 digitalWrite(DIR_MA,HIGH);   // Agugas del reloj
  for(int i = 0; i < pasos_azimut; i++){
      digitalWrite(STEP_MA, HIGH); 
      delay(periodo);
      digitalWrite(STEP_MA, LOW);
      delay(periodo);
      }
}
//---------------------------------------------------------------------------------------------------
//
// Imprime determinados valores
// Función: void imprimir (int hora, float a_elev , float dif_e, int flag_e,float a_azi,float dif_a,int flag_g){
// hora, angulo de elvacion, fiferencia de elevacion, flag de elevacion, angulo de azimut, diferencia de azimut
// flag
// 
void imprimir (int hora, float a_elev , float dif_e, int flag_e,float a_azi,float dif_a,int flag_g){
  
  Serial.print(hora);
  Serial.print("- Elevacion: ");
  Serial.print(a_elev);
  Serial.print("- Dif elev.: ");
  Serial.print(abs(dif_e));
  Serial.print("- Giro E: ");
  Serial.print(flag_e);
  Serial.print(" - Azimut: ");
  Serial.print(a_azi);
  Serial.print("- Dif azi.: ");
  Serial.print(dif_a);
  Serial.print("- Giro Azimut: ");
  Serial.println(flag_g);
  //Serial.print("- llamar a funcion con = ");
  //Serial.println(0);
}

//-------------------------------------------------------------------------------------------------------------
// Calcula Promedio
// Funcion: float promedio (int ind)
// recibe ind : es la cantidad o el denominador para el calculo
// 

float promedio (int ind){
int a;
float prom_an0=0;
float prom_an1=0;
float prom_an2=0;
float prom_an3=0;
    Serial.println(" Funcion promedio ");
    for (a=0; a<=ind;a++){
      prom_an0=an0[a]+prom_an0;
      prom_an1=an1[a]+prom_an1;
      prom_an2=an2[a]+prom_an2;
      prom_an3=an3[a]+prom_an3;
    }
    prom_an0=prom_an0/ind;
    Serial.print("- Promedio AN0: ");
    Serial.println(prom_an0);
    prom_an1=prom_an1/ind;
    Serial.print("- Promedio AN1: ");
    Serial.println(prom_an1);
    prom_an2=prom_an2/ind;
    Serial.print("- Promedio AN2: ");
    Serial.println(prom_an2);
    prom_an3=prom_an3/ind;
    Serial.print("- Promedio AN3: ");
    Serial.println(prom_an3);
    prom_an0=0;
    prom_an1=0;
    prom_an2=0;
    prom_an3=0;
    //ind=0;
}

//-------------------------------------------------------------------------------------------------
// Inicializacion de motores
//
// Funcion: void motores_begin()
// Lleva a 90 grado de elevacion
// Lleva a 0 de elevacion
// Lleva a cero de azimut


void motores_begin(){
 Serial.print("Buscando 90 elevacion....");
  buscar_noventa_elevacion();
  Serial.print("Buscando 0 elevacion....");
  buscar_cero_elevacion();
  //Serial.print("Buscando 180 azimut....");
  //buscar_180_azimut(20);
  Serial.print("Buscando cero azimut....");
  buscar_cero_azimut(20);
   
}

// ---------------------------------------------------------------------------------------------------------------------
// Funcion: void almacenamiento_vector(int visualizo)
//
// si recibe 0 almacena 
// si recibe 1 almacena e imprime el vector

void almacenamiento_vector(int visualizo){
for (int i=0;i<=indice_max;i++){
      //hora_a(hora[i]);
      //hora_array_v[i]=hora_array;
      //min_array_v[i]=min_array;
      if (visualizo==1){
        Serial.print(i);
        Serial.print(": ");
        Serial.print(hora_array_v[i]);
        Serial.print(":");
        Serial.println(min_array_v[i]);
      }
      delay(10);
    }
}

// ---------------------------------------------------------------------------------------------------------------------
// Analisis de la posicion, a partir de esta funcion se decide donde debe comenzar
// Funcion: analisis_posicion()
// 
//

void analisis_posicion(){
Serial.print("Hora recibida: ");
Serial.print(hora_rtc);
Serial.print(" Minutos : ");
Serial.println(min_rtc);
      
if ((hora_rtc>=hora_array_max) || (hora_rtc==0) || (hora_rtc==1)|| (hora_rtc==2) || (hora_rtc==3)|| (hora_rtc==4)|| (hora_rtc==5)) {
    //if (min_rtc>=min_array_max){
    Serial.print("Logica deberia empezar en: ");
    ind=0;
    ind_det=ind;
    Serial.println(ind);
    //}
}else{     
  Serial.println("---------------------------------------------------------------------------------------------");
      //for(int i=1;i<=indice_max;i++){
      for(int i=0;i<=indice_max;i++){
          Serial.print("i: ");
          Serial.print(i);
          Serial.print(" ,");
       // Esta logica queda apuntando siempre al maximo cuando cambia 8:00 - 8:20 - 8:40 (Queda aca en 8:40 como i),  Aqui conincide 3 horas
       // En el caso de "6:48:00","7:00:00" queda apuntando al 7:00 por eso se colocan flag 1,2,3, Aqui solo conincide una hora
       
       if ((hora_rtc <= hora_array_v[i])&&(hora_rtc != hora_array_v[i+1])){
          Serial.print("Hora en el 0 Horas distintas!!!!! if ");
          Serial.print("indice: ");
          Serial.println(i);
          Serial.print(" Horas : ");
          Serial.print(hora_array_v[i]);
          Serial.print(" - ");
          Serial.println(hora_array_v[i+1]);
          Serial.print("Minutos :");
          Serial.println(min_array_v[i]);
          //if ((hora_rtc==hora_array_v[i-3])&&(hora_rtc==hora_array_v[i-2])&&(hora_rtc==hora_array_v[i-1])&&(hora_rtc==hora_array_v[i]))flag=4;
          if ((hora_rtc==hora_array_v[i-2])&&(hora_rtc==hora_array_v[i-1])&&(hora_rtc==hora_array_v[i]))flag=3;
          if ((hora_rtc!=hora_array_v[i-2])&&(hora_rtc==hora_array_v[i-1])&&(hora_rtc==hora_array_v[i]))flag=2;
          if ((hora_rtc!=hora_array_v[i-2])&&(hora_rtc!=hora_array_v[i-1])&&(hora_rtc==hora_array_v[i]))flag=1;
          Serial.print(" flag:  ");
          Serial.println(flag);
         
            if (flag==1){      
              if(min_rtc<=min_array_v[i]) {
                Serial.print(" min_rtc en el 1 if: ");
                Serial.print(min_rtc);
                Serial.print(" min array: ");
                Serial.println(min_array_v[i]);
                ind_det=i;
                ind=ind_det;
                return;
              }else{
                Serial.print(" min_rtc en else 1 if: ");
                Serial.print(min_rtc);
                Serial.print(" min array: ");
                Serial.println(min_array_v[i]);
                ind_det=i+1;
                ind=ind_det;
                return;
              }
            }
           if (flag==2){
             Serial.print(" flag:  ");
             Serial.println(flag);
             return;
           }
           
           if (flag==3){
            Serial.print(" flag:  ");
            Serial.println(flag);
             //------------------------------------------------------------------------------------------------ (1)
                if((min_rtc>=min_array_v[i-1])&& (min_rtc<=min_array_v[i])) {
                  Serial.println("((min_rtc>=min_array_v[i-1])&& (min_rtc<=min_array_v[i]))");
                  //Serial.print(hora_rtc);
                  //Serial.print(":");
                  //Serial.println(min_rtc);
                    ind_det=i;
                    ind=ind_det;
                    return;
                }                 
            //------------------------------------------------------------------------------------------------ (1)
            //------------------------------------------------------------------------------------------------ (2)
                  if((min_rtc>=min_array_v[i-2])&&(min_rtc<=min_array_v[i-1]))  {
                      Serial.print("min_rtc>=min_array_v[i-2])&&(min_rtc<=min_array_v[i-1]");
                      //Serial.print(hora_rtc);
                      //Serial.print(":");
                      //Serial.println(min_rtc);
                      ind_det=i-1;
                      ind=ind_det;
                      return;   
                  }
            //------------------------------------------------------------------------------------------------ (2)
            //------------------------------------------------------------------------------------------------ (3)     
                  if(min_rtc>=min_array_v[i]){
                    Serial.print("(min_rtc>=min_array_v[i])");
                    ind_det=i+1;
                    ind=ind_det;
                    return;
                }  
            //------------------------------------------------------------------------------------------------ (3)    
           Serial.print("Sali sin pasar por ninguna");
           return;
           }// flag 3
                   
      }
    }// for
  } // del If.....
}


//----------------------------------------------------------------------------------------------------------------
//
// Esta funcion imprime la fecha dia, mes, año - hora y minuto
// Funcion: void printDate(DateTime date)
//
void printDate(DateTime date){
   Serial.print(daysOfTheWeek[date.dayOfTheWeek()]);
   Serial.print(" ");
   Serial.print(date.day(), DEC);
   Serial.print('/');
   Serial.print(date.month(), DEC);
   Serial.print('/');
   Serial.print(date.year(), DEC);
   Serial.print(" ");
   Serial.print(date.hour(), DEC);
   Serial.print(':');
   Serial.print(date.minute(), DEC);
   Serial.print(':');
   Serial.print(date.second(), DEC);
   Serial.print(" -->");
}
//--------------------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------------------
// Esta funcion esta pensada si el dispositivo esta vivo, sobre de noche
//
// Funcion: void is_alive()
// Aqui podriamos intentar un mensaje cada hora
// Durante la noche voy enviando datos a la BD en la nube
// Verificando que esta alive
// 
void is_alive(){
   
    if ((hora_rtc==1)&&(min_rtc==15)){
      if (( sec_rtc>=12)&&(sec_rtc<=16)){
        iAN0 =62; //Codigo dentro de alive
        envia();
      }
    }
    if ((hora_rtc==2)&&(min_rtc==15)){
      if (( sec_rtc>=12)&&(sec_rtc<=16)){
        iAN0 =62; //Codigo dentro de alive
        envia();
      }
    }
    if ((hora_rtc==3)&&(min_rtc==40)){
      if (( sec_rtc>=12)&&(sec_rtc<=16)){
        iAN0 =62; //Codigo dentro de alive
        envia();
      }
    }

    if ((hora_rtc==4)&&(min_rtc==15)){
      if ((sec_rtc>=12)||(sec_rtc<=16 )){
        iAN0 =62; //Codigo dentro de alive
        envia();
      }
    }
    if ((hora_rtc==5)&&(min_rtc==15)){
      if ((sec_rtc>=12)||(sec_rtc>=16 )){
        iAN0 =62; //Codigo dentro de alive
        envia();
      }
    }
    if ((hora_rtc==6)&&(min_rtc==15)){
      if ((sec_rtc>=12)||(sec_rtc>=16 )){
        iAN0 =62; //Codigo dentro de alive
        envia();
      }
    }
}

//--------------------------------------------------------------------------------------------------------------
// Funcion de almacenamiento del vector
// Funcion : void hora_max(int indice, int imp)
// recibe el indice del array
// si recibe 0 almacena 
// si recibe 1 almacena e imprime el vector

void hora_max(int indice, int imp){
    //hora_a( hora[indice] );// se trae la hora maxima del array
    //Serial.print("Hora Maxima");
    //Serial.print((hora_array));
    //Serial.print(":");
    //Serial.print((min_array));
    //Serial.print(":");
    //Serial.println((seg_array));
    
    hora_array_max=hora_array_v[indice];
    min_array_max=min_array_v[indice];
    //seg_array_max=seg_array_v[indice];
    if (imp==1){
      Serial.print("Setup hora max...: ");
      Serial.print((hora_array_max));
      Serial.print(":");
      Serial.print((min_array_max));
      //Serial.print(":");
      //Serial.println((seg_array_max));
    }
}

//--------------------------------------------------------------------------------------------------------------
// Funcion de almacenamiento del vector
// Funcion : void hora_min(int indice, int imp)
// recibe el indice del array
// si recibe 0 almacena 
// si recibe 1 almacena e imprime el vector

void hora_min(int indice, int imp){
   // hora_a( hora[indice] );// se trae la hora maxima del array
    //hora_a( hora[1] );// se trae la hora minima del array
    hora_array_min=hora_array_v[indice];
    min_array_min=min_array_v[indice];
    //seg_array_min=seg_array_v[indice];
    if (imp==1){
      Serial.print("Setup hora min...: ");
      Serial.print((hora_array_min));
      Serial.print(":");
      Serial.print((min_array_min));
      //Serial.print(":");
      //Serial.println((seg_array_min));
    }
}
